es-spy
======

Some prototyping and general noodling around to find the right approach for building a source transformation library that could allow debuggers to inspect into every intermediate expression value in real Javascript (ES5.1 and below) code.

The interesting results are in `spy.js`, which could be generalized and expanded into a proper module.

For example, consider inspecting the intermediate values that flow through

    a[++b] = c(f);

We want client code to be able to observe, _in this order_:
  
     a
     b            // before adding 1
     b            // after adding 1
     ToString(b)  // Technically the spec states that any value passed to the 
                  // square-brackets operator is converted to a string first
     c
     f
     c(f)
     
Yet we also want the transformed code to be also be an expression that returns the new value of `a[b]`, as it must fit, interchangeably with the original, into the expression slot of its parent expression or statement.

The tricky part is that we want to be able to send each of these "naked" values to some kind of spy or trace function, yet we want the sequence of property and variable retrievals and assignments to occur strictly in the same order as they would in the untransformed Javascript, without adding extra retrievals or assignments (except to temp variables we insert and which, modulo certain uses of `with` and `eval`, we know do not interfere with inspected code.)

This is desirable for two reasons:
  * "pedagogically", it ensures that the values we report match the intermediate values calculated by a real (spec-compliant) Javascript engine.
  * "paranoically", it ensures that the transformed code works the same even if retrieving or assigning some property has a side effect due to the presence of setters or getters--and remember that variables in global scope or within a `with` statement may actually be a property of an object.
  
Here is an example transformation generated by spy.js. (Assume that `__spy` returns the value passed to it, and that we know that `__spy`, `_1`, `_2`, etc do not collide with existing variables in the current scope)> The last two arguments to `__spy` are the start and end points of the relevant expression.

    d3.select("foo").selectAll("blah").css("a", "b");

becomes (note this is a single comma expression)

    __spy(_1 = d3, 0, 2), 
    __spy(_2 = _1.select, 0, 9), 
    __spy(_3 = _2.call(_1, 'foo'), 0, 16), 
    __spy(_4 = _3.selectAll, 0, 26), 
    __spy(_5 = _4.call(_3, 'blah'), 0, 34), 
    __spy(_6 = _5.css, 0, 38), 
    __spy(_7 = _6.call(_5, 'a', 'b'), 0, 48);


